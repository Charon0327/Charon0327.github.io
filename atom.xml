<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Charon0327.github.io</id>
    <title>Gridea</title>
    <updated>2021-03-21T12:59:01.507Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Charon0327.github.io"/>
    <link rel="self" href="https://Charon0327.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://Charon0327.github.io/images/avatar.png</logo>
    <icon>https://Charon0327.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[主浏览器内核]]></title>
        <id>https://Charon0327.github.io/post/zhu-liu-lan-qi-nei-he/</id>
        <link href="https://Charon0327.github.io/post/zhu-liu-lan-qi-nei-he/">
        </link>
        <updated>2021-03-21T12:58:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="主流浏览器内核">主流浏览器内核</h2>
<h3 id="trident">Trident</h3>
<p>​        说起Trident，大部分人都会觉得比较陌生，但提起IE浏览器基本上是家喻户晓。由于该内核被包含在全世界最高的使用率的操作系统中，即为Windows操作系统，所以我们又经常把它称之为IE内核。采用用Trident内核的浏览器有：IE、傲游、世界之窗浏览器、Avant、腾讯TT、Sleipnir、GOSURF、GreenBrowser和KKman等。<br>
​        Trident(又叫MSHTML)，是微软开发的一种排版引擎。1997年IE4诞生时一同出现，之后被不断地更新和完善。它实际上是一款开放的内核，由于其引擎被设计成一个软件模块，所以其他的软件开发人员就能够在他们开发的应用程序中加入网页的浏览功能。Trident内核接口已经很成熟了，所以有许多采用IE内核的产品。但是IE内核无法在windows操作系统之外的其他操作系统上使用，所以不能跨平台使用。 [1]<br>
​        该内核程序在1997年的IE4中首次被采用，是微软在Mosaic代码的基础之上修改而来的，并沿用到IE11，也被普遍称作”IE内核”。Trident实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用IE内核而非IE的浏览器（壳浏览器）涌现。<br>
​        由于IE本身的“垄断性”（虽然名义上IE并非垄断，但实际上，特别是从Windows 95年代一直到XP初期，就市场占有率来说IE的确借助Windows的东风处于“垄断”的地位）而使得Trident内核的长期一家独大，微软很长时间都并没有更新Trident内核，这导致了两个后果——一是Trident内核曾经几乎与W3C标准脱节（2005年），二是Trident内核的大量Bug等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为IE浏览器不安全的观点，也有很多用户转向了其他浏览器，Firefox和Opera就是这个时候兴起的。非Trident内核浏览器的市场占有率大幅提高也致使许多网页开发人员开始注意网页标准和非IE浏览器的浏览效果问题。<br>
​        补充：IE从版本11开始，初步支持WebGL技术。IE8的JavaScript引擎是Jscript，IE9开始用Chakra，这两个版本区别很大，Chakra无论是速度和标准化方面都很出色。<br>
​        Trident内核的常见浏览器有：　IE6、IE7、IE8（Trident 4.0）、IE9（Trident 5.0）、IE10（Trident 6.0）；360安全浏览器（1.0-5.0为Trident，6.0为Trident+Webkit，7.0为Trident+Blink）猎豹极轻浏览器，360极速浏览器（7.5之前为Trident+Webkit，7.5为Trident+Blink）猎豹安全浏览器（1.0-4.2版本为Trident+Webkit，4.3及以后版本为Trident+Blink）猎豹极轻浏览器，傲游浏览器（傲游1.x、2.x为IE内核，3.x为IE与Webkit双核）、百度浏览器（早期版本）、世界之窗浏览器（最初为IE内核，2013年采用Chrome+IE内核）、2345浏览器、腾讯TT、淘宝浏览器、采编读浏览器、搜狗高速浏览器（1.x为Trident，2.0及以后版本为Trident+Webkit）、阿云浏览器（早期版本）、瑞星安全浏览器、Slim Browser、 GreenBrowser、爱帆浏览器（12 之前版本）、115浏览器、155浏览器、闪游浏览器、N氧化碳浏览器、糖果浏览器、彩虹浏览器、瑞影浏览器、勇者无疆浏览器、114浏览器、蚂蚁浏览器、飞腾浏览器、速达浏览器、佐罗浏览器、海豚浏览器（iPhone/iPad/Android）、UC浏览器（Webkit内核+Trident内核）等。<br>
​        其中部分浏览器的新版本是“双核”甚至是“多核”，其中一个内核是Trident，然后再增加一个其他内核。国内的厂商一般把其他内核叫做“高速浏览模式”，而Trident则是“兼容浏览模式”，用户可以来回切换。</p>
<h3 id="gecko">Gecko</h3>
<p>​        Gecko（Firefox内核）：Netscape6开始采用的内核，后来的Mozilla FireFox（火狐浏览器） 也采用了该内核，Gecko的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因。<br>
​        事实上，Gecko引擎的由来跟IE不无关系，前面说过IE没有使用W3C的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape的一些员工一起创办了Mozilla，以当时的Mosaic内核为基础重新编写内核，于是开发出了Gecko。不过事实上，Gecko 内核的浏览器仍然还是Firefox （火狐） 用户最多，所以有时也会被称为Firefox内核。此外Gecko也是一个跨平台内核，可以在Windows、 BSD、Linux和Mac OS X中使用。<br>
补充：JavaScript引擎是：SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0）。<br>
​        Gecko内核常见的浏览器：Mozilla Firefox、Mozilla SeaMonkey、waterfox（Firefox的64位开源版）、Iceweasel、Epiphany（早期版本）、Flock（早期版本）、K-Meleon。</p>
<h3 id="presto">Presto</h3>
<p>​        Presto（Opera前内核） （已废弃）： Opera12.17及更早版本曾经采用的内核，现已停止开发并废弃，该内核在2003年的Opera7中首次被使用，该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。<br>
​        实际上这是一个动态内核，与前面几个内核的最大的区别就在脚本处理上，Presto有着天生的优势，页面的全部或者部分都能够在回应脚本事件时等情况下被重新解析。此外该内核在执行Javascrīpt的时候有着最快的速度，根据在同等条件下的测试，Presto内核执行同等Javascrīpt所需的时间仅有Trident和Gecko内核的约1/3（Trident内核最慢，不过两者相差没有多大），本文的其中一个修改者认为上述测试信息过于老旧且不完整，因为他曾做过的小测试显示Presto部分快部分慢，各内核总体相当。那次测试的时候因为Apple机的硬件条件和普通PC机不同所以没有测试WebCore内核。只可惜Presto是商业引擎，使用Presto的除开Opera以外，只剩下NDSBrowser、Wii Internet Channle、Nokia 770网络浏览器等，这很大程度上限制了Presto的发展。<br>
​        Opera现已改用Google Chrome的Blink内核。</p>
<h3 id="webkit">Webkit</h3>
<p>​        Webkit（Safari内核，Chrome内核原型，开源）:它是苹果公司自己的内核，也是苹果的Safari浏览器使用的内核。 Webkit引擎包含WebCore排版引擎及JavaScriptCore解析引擎，均是从KDE的KHTML及KJS引擎衍生而来，它们都是自由软件，在GPL条约下授权，同时支持BSD系统的开发。所以Webkit也是自由软件，同时开放源代码。在安全方面不受IE、Firefox的制约，所以Safari浏览器在国内还是很安全的。<br>
限于Mac OS X的使用不广泛和Safari浏览器曾经只是Mac OS X的专属浏览器，这个内核本身应该说市场范围并不大；但似乎根据最新的浏览器调查表明，该浏览器的市场甚至已经超过了Opera的Presto了——当然这一方面得益于苹果转到x86架构之后的人气暴涨，另外也是因为Safari 3终于推出了Windows版的缘故吧。Mac下还有OmniWeb、Shiira等人气很高的浏览器。<br>
​        Google Chrome、360极速浏览器以及搜狗高速浏览器高速模式也使用Webkit作为内核（在脚本理解方面，Chrome使用自己研发的V8引擎）。WebKit 内核在手机上的应用也十分广泛，例如 Google 的手机 Gphone、 Apple 的iPhone， Nokia’s Series 60 browser 等所使用的 Browser 内核引擎，都是基于 WebKit。<br>
WebKit内核常见的浏览器：傲游浏览器3、Apple Safari （Win/Mac/iPhone/iPad）、Symbian手机浏览器、Android 默认浏览器，</p>
<h3 id="blink">Blink</h3>
<p>​        产品简介<br>
​        Blink是一个由Google和Opera Software开发的浏览器排版引擎，Google计划将这个渲染引擎作为Chromium计划的一部分，并且在2013年4月的时候公布了这一消息。这一渲染引擎是开源引擎WebKit中WebCore组件的一个分支，并且在Chrome（28及往后版本）、Opera（15及往后版本）和Yandex浏览器中使用。<br>
相关新闻<br>
​        2013年4月3日，谷歌在Chromium Blog上发表博客，称将与苹果的开源浏览器核心Webkit分道扬镳，在Chromium项目中研发Blink渲染引擎（即浏览器核心），内置于Chrome浏览器之中。<br>
​        苹果在Safari中采用Webkit核心，并于2005年将Webkit公开为开源软件。谷歌当时采用苹果的Webkit核心打造了Chrome浏览器。Opera也宣布称将会转向Webkit核心，但是谷歌宣布此举后，Opera表示将会跟随谷歌采用其Blink浏览器核心，同时参与了Blink的开发。<br>
​        谷歌转向研发Blink浏览器内核意义重大，谷歌此举欲降低Webkit即苹果在浏览器市场的影响力。截止2012年底，Webkit浏览器内核占总浏览器市场份额约40%。谷歌解释称，Chromium多处理架构系统与其他Webkit浏览器很不相同。谷歌工程师Adam Barth在博客中表示，随着浏览器的发展，苹果的Webkit已经不能满足用户需求，同时也有碍浏览器技术的创新步伐。但是他也表示，谷歌自主研发Blink内核绝非易事，但是新内核将会提升整个开源网络生态系统的机能。谷歌做出此举之际，Mozilla与三星也达成合作协议开发“下一代”浏览器渲染引擎Servo。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[移动端布局要素]]></title>
        <id>https://Charon0327.github.io/post/yi-dong-duan-bu-ju-yao-su/</id>
        <link href="https://Charon0327.github.io/post/yi-dong-duan-bu-ju-yao-su/">
        </link>
        <updated>2021-03-08T14:15:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="meta标签">meta标签</h1>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-
scale=1.0,minimum-scale=1.0,user-scaleable=no&quot;&gt;
</code></pre>
<p>名字是<code>viewport</code>，内容是：<br>
width=device-width:我们页面的宽高是 viewport的宽高，也就是我们设备的宽高<br>
initial-scale=1.0:默认的缩放比例是1:1<br>
maximum-scale=1.0：允许用户缩放的最大比例是1.0<br>
minimum-scale=1.0：允许用户缩放的最小比例是1.0<br>
user-scaleable=no：不允许用户手动缩放</p>
<pre><code>meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot;
</code></pre>
<p>不要自动识别手机号和邮箱地址，属于iPhone适配的meta</p>
<pre><code>&lt;meta name=&quot;apple-mobile-app-capable&quot; content=&quot;yes&quot;&gt;
</code></pre>
<p>网站开启对webapp的支持，m站→移动端浏览器的网站</p>
<pre><code>&lt;meta name=&quot;app-mobile-app-status-bar-style&quot; content=&quot;black&quot;&gt;
</code></pre>
<p>改变苹果浏览器顶部状态条的颜色，将它设置为黑色，有白色和灰色</p>
<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;
</code></pre>
<p>默认使用ie的最新版本浏览器以及Chrome浏览器</p>
<h1 id="媒体查询">媒体查询</h1>
<p>@media经常用来实现响应式布局</p>
<pre><code>@media 查询类型 and | not|only(查询条件){
        code...
}
@media 查询类型 and | not|only(查询条件){
        code...
}
@media 查询类型 and | not|only(查询条件){
        code...
}
.......
</code></pre>
<h4 id="屏幕取值的判断"><strong>屏幕取值的判断</strong></h4>
<pre><code>@media(min-width:768px){
    &lt;!-- &gt;=768px的设备 --&gt;
}
@media(min-width:992px){
     &lt;!-- &gt;=992px的设备 --&gt;
}
@media(min-width:1200px){
     &lt;!-- &gt;=1200px的设备 --&gt;
}
</code></pre>
<p><strong>注意：顺序，如果你采用的是min-width的判断方法，那么屏幕的宽度是从小到大的。如果采用的是max-width的判断方法，那么屏幕的宽度是从大到小的</strong><br>
比如说你的屏幕是1440px，</p>
<pre><code>@media(max-width:1199pxx){
    &lt;!-- &lt;=1200px的设备 --&gt;
}
@media(max-width:991px){
     &lt;!-- &lt;=992px的设备 --&gt;
}
@media(max-width:767px){
     &lt;!-- &lt;=768px的设备 --&gt;
}
</code></pre>
<h1 id="em和rem">em和rem</h1>
<p>浏览器的单位：px；em；rem;<br>
px：像素，不能实现自适应<br>
em：单位<br>
  默认情况下，1em=16px,因为浏览器默认字体大小是16px<br>
  正常在使用em的时候，如果给body设置了font-size：62.5%，需要注意给元素添加字号，使用元素的字号来判断该元素的大小等属性<br>
  如果给body设置了font-size：100px，会导致用户自己设置的字体大小不再产生作用，相当于影响了用户的自身体验。<br>
什么时候需要使用em?<br>
简单组件内部使用</p>
<pre><code>&lt;select name=&quot;&quot; id=&quot;&quot;&gt;
    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;
     &lt;option value=&quot;&quot;&gt;&lt;/option&gt;
      &lt;option value=&quot;&quot;&gt;&lt;/option&gt;
       &lt;option value=&quot;&quot;&gt;&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>**em计算 是根据该元素的font-size实现的；该元素的font-size有可能是显示设置的，也可能是通过继承得来的 **</p>
<h1 id="rem">rem</h1>
<p>em:相对于元素自身的font-size进行计算的<br>
rem:root  element(html)  根据根元素的字体大小进行计算，具有统一的计算标准。<br>
浏览器默认字体16px；625%就是100px；所以1rem=100px</p>
<pre><code>html{
    font-size:625%
}
</code></pre>
<p>既能让我们的rem计算方便，又能让浏览器支持，还能和用户自己设置的字体大小产生关联</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[弹性盒]]></title>
        <id>https://Charon0327.github.io/post/dan-xing-he/</id>
        <link href="https://Charon0327.github.io/post/dan-xing-he/">
        </link>
        <updated>2021-02-26T11:29:59.000Z</updated>
        <content type="html"><![CDATA[<p>弹性盒就是自由伸缩的盒子<br>
通常在移动端排版当中，适配屏幕是非常繁琐的事情，是因为各个终端屏幕和像素都不一样，弹性盒能够帮助我们快速适配各个不同的屏幕</p>
<h3 id="弹性盒的主要属性">弹性盒的主要属性:</h3>
<h4 id="弹性盒子的属性">弹性盒子的属性</h4>
<ol>
<li>display:flex; //将当前元素变成弹性盒<br>
inline-flex;<br>
-webkit-flex ;<br>
将盒子转化为弹性盒以后，那么盒子内的元素会默认排成一行;</li>
<li>定义盒子内的元素的排列方向<br>
flex-direction:<br>
row:排成行，也是默认值;<br>
row-reverse:以相反的方向排成一行;<br>
column:排成列<br>
column-reverse：以相反的方向排成一列</li>
<li>定义盒子内的子元素的对齐方式<br>
横向对齐: justify-content:<br>
flex- start默认的对齐方式，从第一个子元素开始对齐;<br>
flex- end:从最后一个子元素开始对齐;<br>
center:从中间位置对齐，平均分布<br>
space-between：两端对齐<br>
space-around：均分空白区域<br>
纵向对齐: align-items:<br>
flex- start:从第一个元素开始对齐，第一个子元素排列在父元素起始位置<br>
flex- end:从最后一个元素开始对齐，最后一个子元素排列在父元素结束位置<br>
center:从中间开始对齐<br>
baseline :从元素的基线对齐<br>
stretch:拉伸对齐</li>
<li>规定子元素在父元素内是否换行<br>
flex-wrap：<br>
nowrap：不换行，一行显示，所以有可能溢出，默认值<br>
wrap：换行显示<br>
wrap-reverse：换行，但是以相反的顺序来排序<br>
initial：设置属性值为该属性的默认值<br>
inherit：继承父元素的属性值</li>
<li>设置行的行为<br>
align-content :<br>
flex-start:项目位于父元素的开头<br>
flex-end:项目位于父元素的末尾<br>
center:项目位于父元素的中心<br>
space-between:项目位于父元素的两端，中间留有空白<br>
space-around :均分父元素的空白区域<br>
stretch:默认值，项目被拉伸来适应父元素</li>
</ol>
<h4 id="弹性盒内的子元素的属性">弹性盒内的子元素的属性</h4>
<ol>
<li>margin值<br>
居中的效果: margin: auto;<br>
等同于给父元素添加横向纵向都居中对齐</li>
<li>order:规定子元素的显示顺序<br>
order:<br>
默认值是0，负数向前，正数向后排列，<br>
如果同时添加多个order,那么数字小的排列在前面</li>
<li>flex:规定子元素所占据的空间<br>
flex:1,2,3,</li>
<li>align-self:覆盖父元素的align- items属性;<br>
auto:默认值，继承父元素的属性，如果父元素没有设置该属性，则为stretch;<br>
stretch:元素被拉伸以适应父元素<br>
center:元素位于父元素的中心<br>
flex-start :元素位于父元素的开始位置<br>
flex-end:元素位于父元素的额结束位置<br>
baseline:元素位于父元素的基线上</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS中的属性应用(2)]]></title>
        <id>https://Charon0327.github.io/post/css-zhong-de-shu-xing-ying-yong-2/</id>
        <link href="https://Charon0327.github.io/post/css-zhong-de-shu-xing-ying-yong-2/">
        </link>
        <updated>2021-02-26T04:08:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="渐变">渐变</h1>
<p>gradient有两种，分别是线性渐变和圆形渐变<br>
线性渐变默认的方向是从上往下的<br>
<code>background: -webkit-linear-gradient(red,blue);</code><br>
如果想指定方向，可以使用left，right，top等,也可以使用角度<br>
<code>background: -webkit-linear-gradient(left top,red,blue);</code><br>
使用角度的时候，0deg是向上的，但是我们的浏览器使用了旧的计算方法: 90-x=y, 所以当角度为0<br>
deg的时候，我们看到的渐变是从左往右的<br>
也可以给渐变添加多个颜色值<br>
<code>background: -webkit-linear-gradient(left top,red,blue,pink,green)</code><br>
颜色也可指定透明度<br>
<code>rgba(255,0,0,0-1)</code><br>
<code>background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,0.5),rgba(255,0,0,1))</code><br>
颜色位置也可以自定义<br>
<code>background: -webkit-linear-gradient(left,#000 25%,#fff 25%,#fff 50%,#000,50%,#000 75%，#fff 75%)</code></p>
<p>圆形渐变是从元素的中心开始的<br>
<code>background: -webkit-radial-gradient(red,blue);</code><br>
指定圆形渐变的形状 circle，ellipse<br>
<code>background: -webkit-radial-gradient(circle,red,blue);</code><br>
至少两个参数，分别代表从某种颜色变化为另外一种颜色</p>
<h1 id="列column">列column</h1>
<p>主要属性:<br>
column-count:指定元素分成多少列(number)<br>
column-width:指定每一列的宽度(number)<br>
column-gap:列与列间的空白(number)<br>
column-rule:分隔符的样式(颜色线的形状宽)<br>
column-span:指定某元素横跨多少列(1|all)<br>
columns: column-count 和 column-width 简写</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS中的属性应用(1)]]></title>
        <id>https://Charon0327.github.io/post/css-zhong-de-shu-xing-ying-yong/</id>
        <link href="https://Charon0327.github.io/post/css-zhong-de-shu-xing-ying-yong/">
        </link>
        <updated>2021-02-24T05:50:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="css3中的边框">CSS3中的边框</h1>
<ol>
<li>圆角<br>
<code>border-radius:value</code><br>
value的取值：number  (px)  或者百分比<br>
单独的圆角：top-left|top-right|bottom-left|bottom-right</li>
<li>阴影<br>
<code>box-shadow:a b c d e f</code><br>
a:左右的阴影，a&gt;0阴影是右边的，a&lt;0阴影是左边的<br>
b:上下的阴影，b&gt;0阴影是下边的，b&lt;0阴影是上边的<br>
c:阴影的模糊半径<br>
d:阴影外延的长度<br>
e:阴影的颜色<br>
f:阴影的方向是向内还是向外<br>
单边阴影：<code>box-shadow:10px 00 red;</code></li>
<li>图画边框<br>
background:背景图<br>
<code>border-image:url(&quot;&quot;) a b c</code><br>
a:上下距离的切割半径<br>
b:左右距离的切割半径<br>
c:背景图的排列方式</li>
</ol>
<h1 id="transition过渡">transition过渡</h1>
<p>width：100px===&gt;200px<br>
<code>transition:attr duration timing-function delay;</code><br>
attr:要变化的属性<br>
duration:过渡的时间（s/ms）<br>
timing-function:过渡的曲线<br>
delay:延迟的时间</p>
<p>timing-function：<br>
  ease：默认值，逐渐变慢<br>
  linear：直线变化<br>
  ease-in：加速<br>
  ease-out：减速<br>
  ease-in-out：先慢再快再慢<br>
  cubic-bezier：贝塞尔曲线（x1,y1,x2,y2）</p>
<h1 id="transform-变形">transform 变形</h1>
<p>浏览器象限：右边是x轴正方向；下边是y轴正方向。<br>
旋转：顺时针为正方向<br>
transform:translate(平移)  rotate(旋转) scale(缩放) shew(倾斜)<br>
只向x平移<code>transform:translateX(100px)</code><br>
只沿y轴旋转<code>transform:rotateY(45deg)</code><br>
只在x轴缩放<code>transform:scaleX(2)</code><br>
倾斜45度<code>transform:shew(45deg)</code></p>
<h1 id="animation动画">animation动画</h1>
<ol>
<li>定义动画<br>
@keyframes animationName{<br>
规定动画执行的内容<br>
}<pre><code>@keyframes ani{
    from{
        width:100px;
    }
    to{
        width:1000px;
    }
}
</code></pre>
或</li>
</ol>
<pre><code>@keyframes ani{
    0%{
        width:100px
        background: blue ;
    }
    25%{
        width :200px;
        backg round: yellow;
    }
    50%{
        width : 400px;
        background: red ;
    }
    75%{
        width : 600px ;
        background: black;
    }
    100%{
        width: 700px;
        background: blue ;
    }
}
</code></pre>
<ol start="2">
<li>调用动画<br>
<code>animation:name duration timing-function delay iteration-cont direction</code><br>
name:动画的名称<br>
duration:动画完成一次的时长(s/ms) ，默认值是0<br>
timing-function:动画曲线，默认值是ease<br>
delay :动画延迟的时间，默认值是0<br>
iteration-cont :动画执行几次，默认值是1<br>
direction:动画的方向，默认值是normal, 另外一个值是alternate</li>
</ol>
<h1 id="文字样式">文字样式</h1>
<h3 id="文字阴影text-shadow">文字阴影text-shadow</h3>
<p><code>text-shadow：a b c d</code><br>
a:阴影左右方向平移距离<br>
b:阴影垂直方向的平移距离<br>
c:阴影的模糊半径<br>
d:阴影的颜色</p>
<h3 id="文字镂空">文字镂空</h3>
<pre><code>-webkit-text-stroke:2px skyblue;
color:transparent;
</code></pre>
<h3 id="长单词换行">长单词换行</h3>
<pre><code>word-wrap：break-word；
width：30px;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字体图标]]></title>
        <id>https://Charon0327.github.io/post/zi-ti-tu-biao/</id>
        <link href="https://Charon0327.github.io/post/zi-ti-tu-biao/">
        </link>
        <updated>2021-02-22T10:58:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="字体图标">字体图标</h1>
<p>就是把字体当成图标来使用<br>
通常使用图片来制作图标，现在就是利用字体将图片制作出来的原因:<br>
1. 图片体积很大，造成用户流量的浪费<br>
2. 图片不能设置样式，只能更换，但是字体可以<br>
3. 加载图片需要http请求，提升了用户的体验<br>
怎么使用字体图标?<br>
打开百度，搜索iconfont-阿里巴巴矢量图标=》进入官网=》登陆=》点击图标管理下我的项目=》点击右<br>
边紫色+新建项目=》来到图标库=》找找自己想要的图标，添加入库=》点击购物车将图标添加至项目=》<br>
回到你的项目中<br>
使用字体图标:</p>
<ol>
<li>使用类名， 用link标签引入iconfont.css<br>
<code>&lt;em class=&quot;icon iconfont icon-xing1&quot;&gt;&lt;/em&gt;</code></li>
<li>使用symbol，使用<code>script</code>标签引入iconfont.js</li>
</ol>
<pre><code>&lt;style&gt;
    .icon{
    /*通过设置font-size, 来改变图标大小*/
    width: 1em; height: iem ;
    /*图标和文字相邻时，垂直对齐*/
    vertical-align: -0. 15em;
    /*通过设置color来改变SVG的颜色/fill */
    fill: currentColor;
    /* path和stroke 溢出viewBox 部分在IE 下会显示normalize.css中也包含这行*/
    over flow: hidden;
}
&lt;/style&gt;

&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;
    &lt;use xlink:href=&quot;icon-xing&quot;&gt;&lt;/use&gt;
&lt;/svg&gt;
</code></pre>
<ol start="3">
<li>使用Unicode</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3中的伪类元素]]></title>
        <id>https://Charon0327.github.io/post/css3-zhong-de-wei-lei-yuan-su/</id>
        <link href="https://Charon0327.github.io/post/css3-zhong-de-wei-lei-yuan-su/">
        </link>
        <updated>2021-02-22T10:43:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="伪类元素">伪类元素</h2>
<p>:after   ::after<br>
用于在一个元素的后面生成内容<br>
:before   ::before<br>
用于在一个元素的前面生成内容</p>
<p>他们都可以通过定义一个 <code>content</code>的属性来生成指定的内容, <code>content</code>属性值可以是：</p>
<ol>
<li>文本或字符串</li>
<li>也可以通过url导入图片等</li>
</ol>
<p>说明：因为以上两个方法生成的内容都说是内联的形式展示的，所以在定义他们的时候，一定记得将他们转成块元素。<br>
:after   通常用于清除浮动</p>
<pre><code>.clearfix:after{
    content:&quot;&quot;;
    display:block;
    width:0;
    height:0;
    overflow:hidden;
    clear:both;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[html5新标签介绍]]></title>
        <id>https://Charon0327.github.io/post/html5-xin-biao-qian-jie-shao/</id>
        <link href="https://Charon0327.github.io/post/html5-xin-biao-qian-jie-shao/">
        </link>
        <updated>2021-02-20T10:25:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="新增标签"><strong>新增标签</strong></h2>
<p>header→头部<br>
nav→导航<br>
section→主体<br>
article→文章<br>
footer→尾部</p>
<p>input<br>
    type：text/url/password/submit/number/email/tel/date/search/range<br>
    autofocus→文本框自动获得焦点<br>
    require→该文本框是必填项</p>
<p>small→小号字体<br>
big→大号字体</p>
<p>data-*：自定义属性<br>
<code>&lt;header id=&quot;head&quot; data-title=&quot;head&quot;&gt;&lt;/header&gt;</code></p>
<p>contenteditable:可以让用户编辑网页上的文本内容</p>
<h2 id="新增的api跟js相关的"><strong>新增的API(跟js相关的)</strong></h2>
<p>audio/vedio/SVG/canvas/本地存储/离线缓存.......</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS图片精灵/三列布局]]></title>
        <id>https://Charon0327.github.io/post/css-tu-pian-jing-ling-san-lie-bu-ju/</id>
        <link href="https://Charon0327.github.io/post/css-tu-pian-jing-ling-san-lie-bu-ju/">
        </link>
        <updated>2021-02-20T02:59:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="图片精灵">图片精灵</h1>
<p>css sprites就是CSS精灵，通过背景定位技术布局网页背景。因为图片多的话，会增加http的请求，使得网站性能降低。<br>
<strong>➢适合:-般小图标素材</strong><br>
小的图标ico类素材, -般图标很小十多像素几十像素的宽度高度，这种适合拼合成张图实现sprites background背景定位布局。小icon太多自然加载网页时瞬间会消耗些http请求链接数;<br>
<strong>➢不适合:大图大背景</strong><br>
大背景一般用于网页背景,拼合时,设置为网页背景时所有背景都会显示出来。大图拼接拼合会增大图片大小，网络带宽不好的访问者访问时由于背景图大文件大会加载稍慢些，所以大图不推荐拼接拼合来使用css sprites背景定位布局。<br>
<strong>➢sprites适合推荐小结</strong><br>
一般此sprites拼合布局用于局部小盒子布局不适合大背景大布局背景使用。比如小局部布局<br>
小图标背景、小导航背景等DIVCSS布局。<br>
通过给盒子一个背景图片，然后通过background-position调节位置</p>
<h1 id="三列布局的创建">三列布局的创建</h1>
<p>所谓三列自适应布局指的是两边定宽,中间block宽度自适应。只需给宽度自适应两列布局中间再加一列，然后重新计算三列的宽度，就实现了宽度自适应的三列布局。同样的道理，更多列的布局，其实和两列、三列的布局模式是一样的。<br>
<strong>常用方法:</strong></p>
<ol>
<li>定位<br>
左右两栏采用绝对定位,固定宽度，分别固定于页面的左右两侧，中间的主体栏用左右margin值撑开距离。于是实现了三栏自适应布局。</li>
</ol>
<pre><code>      &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
  	&lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt;
  	&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
  		*{
  			margin: 0;
  			padding: 0;
  		}
  		.left{
  			width: 200px;
  			height: 500px;
  			background-color: aqua;
  			position: absolute;
  			left: 0;
  			top: 0;
  		}
  		.right{
  			width: 200px;
  			height: 500px;
  			background-color: aqua;
  			position: absolute;
  			right: 0;
  			top: 0;
  		}
  		.middle{
  			height: 600px;
  			background-color: burlywood;
  			margin: 0 200px;
  		}
</code></pre>
<ol start="2">
<li>浮动<br>
左栏左浮动，右栏右浮动，主体直接<strong>放在后面</strong>就实现了自适应。</li>
</ol>
<pre><code>   &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
		&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
		&lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
			*{
				margin: 0;
				padding: 0;
			}
			.left{
				width: 200px;
				height: 500px;
				background-color: aquamarine;
				float: left;
			}
			.right{
				width: 200px;
				height: 500px;
				background-color: aquamarine;
				float: right;
			}
			.center{
				height: 500px;
				background-color: coral;
                margin: 0 200px;
                min-width: 300px;/*小于300px固定不动*/
			}
</code></pre>
<h5 id="min-heigthwidth">min-heigth/width</h5>
<p>min方法定义了元素的最小的宽高度,该属性值会对元素的高度设置一个最低限制。因此,元素可以比指定值宽与高,但不能比其矮。不允许指定负值。取值单位: px/%;<br>
<code>div{min-width:500px;min-height:300px;}</code><br>
当页面发生改变的时候,元素保留最小宽高度，超出滚动条代替</p>
<h5 id="max-heigthwidth">max-heigth/width</h5>
<p>max方法定义了元素的最大的宽高度，该属性值会对元素的高度设置一个最大限制。因此，元素可以比指定值宽与高，但不能比其高。不允许指定负值。取值单位: px/%;<br>
<code>div{max width:500px;max- height:300px;}</code><br>
此属性很少使用,是为了避免内容太多将高度撑太高影响布局美化统一，这个时候我们设置最大高度限制。比如一个table tr td表格对象里装一个图片，而图片高度不确定，如果太高了不想图片撑破tr td表格,这个时候通过css max-height限制图片最大高度<br>
是有必要的。<br>
3.  弹性盒布局</p>
<h3 id="三列布局经典案例">三列布局经典案例</h3>
<p>完成下列布局需求:<br>
A为顶部块，固定在顶部，不随滚动条滚动<br>
B为左侧快，固定宽度300px<br>
C为右侧块，固定宽度300px<br>
D为主内容块，宽度随页面宽度变化<br>
E为底部块,</p>
<ol>
<li>当页面高度不足时，按图显示(无滚动条)</li>
<li>屏幕高度小于内容区域高度时，出现滚动条<br>
<img src="https://Charon0327.github.io/post-images/1613793661162.PNG" alt="" loading="lazy"></li>
</ol>
<pre><code>*{
				margin: 0;
				padding: 0;
				font-size: 40px;
			}
			html,body{
				height: 100%;
			}
			.main-wp{
				min-height: 100%;
			}
			.header{
				height: 60px;
				line-height: 60px;
				width: 100%;
				background-color: #ccc;
				position: fixed;
				top: 0;
				left: 0;
			}
			.left{
				width: 300px;
				background-color: blue;
				float: left;
				height: 400px;
			}
			.right{
				float: right;
				width: 300px;
				background-color: yellow;	
				height: 400px;
			}
			.center{
				background-color: pink;
				margin: 0 300px;
				height: 700px;
			}
			.main{
				/* margin-top: 60px; */
			}
			.footer{
				margin-top: -60px;
				background-color: #ccc;
				height: 60px;
			}
			.empty{
				height: 60px;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div class=&quot;main-wp&quot;&gt;
			&lt;div class=&quot;header&quot;&gt;head&lt;/div&gt;
			&lt;div class=&quot;empty&quot;&gt;&lt;/div&gt;
			&lt;div class=&quot;main&quot;&gt;
				&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
				&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
				&lt;div class=&quot;center&quot;&gt;center&lt;/div&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&quot;empty&quot;&gt;&lt;/div&gt;
		&lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[案例]]></title>
        <id>https://Charon0327.github.io/post/an-li/</id>
        <link href="https://Charon0327.github.io/post/an-li/">
        </link>
        <updated>2021-02-19T09:42:08.000Z</updated>
        <content type="html"><![CDATA[<h4 id="title标题中的图片导入方式">title标题中的图片导入方式</h4>
<p><code>&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/icon&quot; href=&quot;img/favicon.ico&quot;&gt;</code></p>
]]></content>
    </entry>
</feed>